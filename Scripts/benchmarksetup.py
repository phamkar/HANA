# -*- coding: utf-8 -*-
"""BenchmarkSetup

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lXTO3pxQvRnG-fA7S82OkYw4OURdoZpk
"""

#@title Install Dependencies
! pip -q install nmrglue
! pip -q install pynmrstar

#@title All together now! La, Da, Da
import os
import numpy as np
import nmrglue as ng
import pynmrstar
import json
from math import sqrt

AAA_dict = {'CYS': 'C', 'ASP': 'D', 'SER': 'S', 'GLN': 'Q', 'LYS': 'K',
  'ILE': 'I', 'PRO': 'P', 'THR': 'T', 'PHE': 'F', 'ASN': 'N',
  'GLY': 'G', 'HIS': 'H', 'LEU': 'L', 'ARG': 'R', 'TRP': 'W',
  'ALA': 'A', 'VAL':'V', 'GLU': 'E', 'TYR': 'Y', 'MET': 'M'}
A_dict = {'C': 'CYS', 'D': 'ASP', 'S': 'SER', 'Q': 'GLN', 'K': 'LYS',
  'I': 'ILE', 'P': 'PRO', 'T': 'THR', 'F': 'PHE', 'N': 'ASN',
  'G': 'GLY', 'H': 'HIS', 'L': 'LEU', 'R': 'ARG', 'W': 'TRP',
  'A': 'ALA', 'V':'VAL', 'E': 'GLU', 'Y': 'TYR', 'M': 'MET'}

def read_bmrb(fname=None, ename=None):
  try:
    if fname != None:
      strentry = pynmrstar.Entry.from_file(fname)
    elif ename != None:
      strentry = pynmrstar.Entry.from_database(ename)
    else:
      return {}
  except:
    return {}

  # Title
  info_saveframes = strentry.get_saveframes_by_category('entry_information')
  title = info_saveframes[0]['Title'][0].strip()

  # extract sequences
  sequence_loops = strentry.get_loops_by_category('_Entity_comp_index')
  sequence_dict = json.loads(sequence_loops[0].get_json())
  sequence_list = list(map(lambda x: [x[1], x[2], AAA_dict[x[2]]],
                           sequence_dict['data']))
  fasta = ''.join(list(map(lambda x: x[2], sequence_list)))

  # extract chemical shifts
  atom_chem_shift_loops = strentry.get_loops_by_category('atom_chem_shift')

  # First, try from bond and chemical shift information
  # shift_list includes a set of lists:
  #     [nseq, 3-letter-seq, 1-letter-seq, chemical shift]
  atom_chem_shift_dict = json.loads(atom_chem_shift_loops[0].get_json())
  shift_list = list(map(lambda x: [x[4], x[6], AAA_dict[x[6]], x[7], x[10]],
                              atom_chem_shift_dict['data']))

  return {'Title': title, 'Fasta': fasta,
          'Sequence List': sequence_list,
          'Chemical Shifts': shift_list}
def distance3D(atom1, atom2):
  """ takes two coordinates. ex: ((26.266, 25.413, 2.842),
                                  (26.913, 26.639, -3.51))
      returns the distance
  """
  return sqrt((atom1[0] - atom2[0]) ** 2 +
              (atom1[1] - atom2[1]) ** 2 +
              (atom1[2] - atom2[2]) ** 2)

def readPDB(pdb_file, modelnumber):
  """
  Parameters
  ----------
  uploaded_pdb : address to a .pdb file
  modelnumber : the model number in the pdb (starting from 1)
  Returns
  -------
  pdb_list: a list of each [Nseq, atom's coordinates, aa, atom]
  """
  pdbLines, modelList = [], []
  tempLines = open(pdb_file, 'r').readlines()

  # clean
  for line in tempLines:
    #print(line)
    if line[0:4] in ['MODE', 'ATOM', 'ENDM']:
      pdbLines.append(line)

  # fill modelList
  for line in pdbLines:
    if line[0:5] == 'MODEL':
      modelList.append([])
    if line[0:4] != 'ATOM':
      continue
    if line[12:16].strip()[0] not in ['H']:
      continue
    aaa = line[17:20].strip()
    atm = line[12:16].strip()
    nSeq = int(line[23:26].strip()) # <residue sequence>
    x = float(line[30:38].strip())
    y = float(line[38:46].strip())
    z = float(line[46:54].strip())
    c = line[21:22].strip() # <chain_ID>
    # in case MODEL not in PDB.
    if len(modelList) == 0:
      modelList.append([])

    modelList[-1].append( [nSeq, x, y, z, aaa, AAA_dict[aaa], atm, c] )

  return modelList[modelnumber - 1]

def createDistanceMatrix(pdb_list):
  distMat = np.zeros( (len(pdb_list), len(pdb_list), 4, 4 ) )
  keyList = []
  c_list = 'ABCD'
  for i in range(len(pdb_list)):
    nSeq, x, y, z, aaa, a, atm, c = pdb_list[i]
    keyList.append(c+'_'+a+str(nSeq)+atm)
    for j in range(i+1, len(pdb_list)):
      nSeq2, x2, y2, z2, aaa2, a2, atm2, c2 = pdb_list[j]
      dist = distance3D( (x, y, z), (x2, y2, z2))

      distMat[i, j, c_list.index(c), c_list.index(c2)] = \
        distMat[j, i, c_list.index(c2), c_list.index(c)] = dist

  return distMat, keyList

def hhDist (pdb_list):
  distList = []
  atmList = []
  resList = []
  coordList = []
  for i in range(len(pdb_list)):
    nSeq, x, y, z, aaa, a, atm, c = pdb_list[i]
    for j in range(i+1, len(pdb_list)):
      nSeq2, x2, y2, z2, aaa2, a2, atm2, c2 = pdb_list[j]
      dist = distance3D( (x, y, z), (x2, y2, z2))

      if atm2[0] not in ['H']:
        continue

      if distMat[i, j, 0, 1] > 5.5:
        continue

      if distMat[i, j, 0, 1] > 0.01 and distMat[i, j, 0, 1] < 5.5:
        dist = distMat[i, j, 0,1] * 1.4  # giving 'rubber band' 40% more resistance
        distRound = round(dist, 2)
        atmList.append(atm)
        atmList.append(atm2)
        #distList.append(str(nSeq) +'_'+ atm +'-'+ str(nSeq2) + '_' +atm2)
        distList.append(distRound)
        resList.append(str(nSeq))
        resList.append(str(nSeq2))
        coordList.append(str(nSeq)+ atm + str(x) + str(y) + str(z) + ' and ' + \
                         str(nSeq2) + atm2 + str(x2) +str(y2) + str(z2))


  return {'HH Distance':distList,
          'HH atoms': atmList,
          'HH Residues': resList,
          'HH coordinates': coordList}


def get_shift(seqidx, atomname):
  filterAtoms = list(filter(lambda x :x[0] == str(seqidx) and x[3] ==atomname,
                            chemShifts))
  if len(filterAtoms) == 0:
    return -9999
  return float(filterAtoms[0][4])

def distance2height(HHdist, offset = 0.0):
  """ distance scaling using r^-3 approximation for H-H """

  min_cc = 1.7  # closest distance between H atoms (1.70 A)
  max_cc = 3.4  # farthest distance observed between H atoms (1.70 * 2)

  approx = -3.0
  dist = min(HHdist, max_cc-offset)
  dist = max(HHdist, min_cc-offset)

    # A * r**-3 + B = I
    # A * min_cc**-3 + B = 1000000
    # A * max_cc**-3 + B = 10000
    # (min_cc**-3 - max_cc**-3) * A = 99000
  A = 990000.0 / ((min_cc-offset)**approx - (max_cc-offset)**approx)       # 75227372.04997641
  B = 10000.0 - A * (max_cc-offset)**-(min_cc-offset)                      # -19444.257193289242

  return A * dist**approx + B

#@title Finding Homodimer from PDB

pdb_seqres_url = 'https://files.wwpdb.org/pub/pdb/derived_data/pdb_seqres.txt'
pdb_entrytype_url = 'https://files.wwpdb.org/pub/pdb/derived_data/pdb_entry_type.txt'

import os
if not os.path.exists(pdb_seqres_url):
  os.system('wget ' + pdb_seqres_url)

if not os.path.exists(pdb_entrytype_url):
  os.system('wget ' + pdb_entrytype_url)

f = open('pdb_seqres.txt', 'r')
lines = f.readlines()
f.close()

f = open('pdb_entry_type.txt', 'r')
elines = f.readlines()[1:]
f.close()

edict = {}
for line in elines:
  sp_list = line.strip().split()
  edict[sp_list[0]] = sp_list[1:]


homodimers = []
for i in range(len(lines)-5):
  line = lines[i]
  if line[0] != '>':
    continue

  # only proteins
  if line.find('mol:protein') == -1:
    continue

  # CHAIN A
  if line[6] != 'A':
    continue

  # CHAIN B
  if lines[i+2][6] != 'B':
    continue

  # HOMODIMER?
  if lines[i+1] != lines[i+3]:
    continue

  if lines[i+4][6] != 'A':
    continue

  sp_list = line.split()
  nseq = int(sp_list[2].replace('length:', ''))

  # protein size between 40 and 400
  if nseq > 400 or nseq < 40:
    continue

  #NMR?
  pdb_id = line[1:5]
  try:
    if edict[pdb_id][1] != 'NMR':
      continue
  except:
    print(pdb_id + ' not exist')
    continue
  a = ''
  # this is proper homodimer by NMR.
  print(line.strip())
  print(lines[i+1].strip())
  homodimers.append([pdb_id, line.strip(), lines[i+1].strip()])

#content = ''
#for homodimer in homodimers:
#  content += str(homodimer) +'\n'
#print (content)
#f = open('homodimersPDB.txt', 'w')
#f.write (content)
#f.close()

#print(str(len(homodimers)) + ' homodimers determined by NMR between 40 and 400 found.')

#@title Parse BMRB
'''
# Download and parse BMRB
parsed_dict = parse_bmrb.read_bmrb(ename='25793')
'''

import os
import numpy as np
import nmrglue as ng
import pynmrstar
import json

AAA_dict = {'CYS': 'C', 'ASP': 'D', 'SER': 'S', 'GLN': 'Q', 'LYS': 'K',
  'ILE': 'I', 'PRO': 'P', 'THR': 'T', 'PHE': 'F', 'ASN': 'N',
  'GLY': 'G', 'HIS': 'H', 'LEU': 'L', 'ARG': 'R', 'TRP': 'W',
  'ALA': 'A', 'VAL':'V', 'GLU': 'E', 'TYR': 'Y', 'MET': 'M'}
A_dict = {'C': 'CYS', 'D': 'ASP', 'S': 'SER', 'Q': 'GLN', 'K': 'LYS',
  'I': 'ILE', 'P': 'PRO', 'T': 'THR', 'F': 'PHE', 'N': 'ASN',
  'G': 'GLY', 'H': 'HIS', 'L': 'LEU', 'R': 'ARG', 'W': 'TRP',
  'A': 'ALA', 'V':'VAL', 'E': 'GLU', 'Y': 'TYR', 'M': 'MET'}

def read_bmrb(fname=None, ename=None):
  try:
    if fname != None:
      strentry = pynmrstar.Entry.from_file(fname)
    elif ename != None:
      strentry = pynmrstar.Entry.from_database(ename)
    else:
      return {}
  except:
    return {}

  # Title
  info_saveframes = strentry.get_saveframes_by_category('entry_information')
  title = info_saveframes[0]['Title'][0].strip()

  # extract sequences
  sequence_loops = strentry.get_loops_by_category('_Entity_comp_index')
  sequence_dict = json.loads(sequence_loops[0].get_json())
  sequence_list = list(map(lambda x: [x[1], x[2], AAA_dict[x[2]]],
                           sequence_dict['data']))
  fasta = ''.join(list(map(lambda x: x[2], sequence_list)))

  # extract chemical shifts
  atom_chem_shift_loops = strentry.get_loops_by_category('atom_chem_shift')

  # First, try from bond and chemical shift information
  # shift_list includes a set of lists:
  #     [nseq, 3-letter-seq, 1-letter-seq, chemical shift]
  atom_chem_shift_dict = json.loads(atom_chem_shift_loops[0].get_json())
  shift_list = list(map(lambda x: [x[4], x[6], AAA_dict[x[6]], x[7], x[10]],
                              atom_chem_shift_dict['data']))

  return {'Title': title, 'Fasta': fasta,
          'Sequence List': sequence_list,
          'Chemical Shifts': shift_list}
results = read_bmrb(ename=25793)
print(results)

# TO DO:
# READ AND PARSE PDB
# C13-NOESY, N15-NOESY based on PDB and BMRB

#@title Parsing PDB

import os
import numpy as np
from math import sqrt

# download pdb
PDB_ID = '2N74' #@param

if not os.path.exists(PDB_ID + '.pdb'):
  ! wget https://files.rcsb.org/download/{PDB_ID}.pdb

#amino acid sequence
AAA_dict = {'CYS': 'C', 'ASP': 'D', 'SER': 'S', 'GLN': 'Q', 'LYS': 'K',
     'ILE': 'I', 'PRO': 'P', 'THR': 'T', 'PHE': 'F', 'ASN': 'N',
     'GLY': 'G', 'HIS': 'H', 'LEU': 'L', 'ARG': 'R', 'TRP': 'W',
     'ALA': 'A', 'VAL':'V', 'GLU': 'E', 'TYR': 'Y', 'MET': 'M'}

def distance3D(atom1, atom2):
  """ takes two coordinates. ex: ((26.266, 25.413, 2.842),
                                  (26.913, 26.639, -3.51))
      returns the distance
  """
  return sqrt((atom1[0] - atom2[0]) ** 2 +
              (atom1[1] - atom2[1]) ** 2 +
              (atom1[2] - atom2[2]) ** 2)

def readPDB(pdb_file, modelnumber):
  """
  Parameters
  ----------
  uploaded_pdb : address to a .pdb file
  modelnumber : the model number in the pdb (starting from 1)
  Returns
  -------
  pdb_list: a list of each [Nseq, atom's coordinates, aa, atom]
  """
  pdbLines, modelList = [], []
  tempLines = open(pdb_file, 'r').readlines()

  # clean
  for line in tempLines:
    #print(line)
    if line[0:4] in ['MODE', 'ATOM', 'ENDM']:
      pdbLines.append(line)

  # fill modelList
  for line in pdbLines:
    if line[0:5] == 'MODEL':
      modelList.append([])
    if line[0:4] != 'ATOM':
      continue
    if line[12:16].strip()[0] not in ['H']:
      continue
    aaa = line[17:20].strip()
    atm = line[12:16].strip()
    nSeq = int(line[23:26].strip()) # <residue sequence>
    x = float(line[30:38].strip())
    y = float(line[38:46].strip())
    z = float(line[46:54].strip())
    c = line[21:22].strip() # <chain_ID>
    # in case MODEL not in PDB.
    if len(modelList) == 0:
      modelList.append([])

    modelList[-1].append( [nSeq, x, y, z, aaa, AAA_dict[aaa], atm, c] )

  return modelList[modelnumber - 1]

def createDistanceMatrix(pdb_list):
  distMat = np.zeros( (len(pdb_list), len(pdb_list), 4, 4 ) )
  keyList = []
  c_list = 'ABCD'
  for i in range(len(pdb_list)):
    nSeq, x, y, z, aaa, a, atm, c = pdb_list[i]
    keyList.append(c+'_'+a+str(nSeq)+atm)
    for j in range(i+1, len(pdb_list)):
      nSeq2, x2, y2, z2, aaa2, a2, atm2, c2 = pdb_list[j]
      dist = distance3D( (x, y, z), (x2, y2, z2))

      distMat[i, j, c_list.index(c), c_list.index(c2)] = \
        distMat[j, i, c_list.index(c2), c_list.index(c)] = dist

  return distMat, keyList
def hhDist (pdb_list):
  distList = []
  atmList = []
  resList = []
  #coordList = []
  for i in range(len(pdb_list)):
    nSeq, x, y, z, aaa, a, atm, c = pdb_list[i]
    for j in range(i+1, len(pdb_list)):
      nSeq2, x2, y2, z2, aaa2, a2, atm2, c2 = pdb_list[j]
      dist = distance3D( (x, y, z), (x2, y2, z2))

      #if atm2[0] not in ['H']:
       # continue

      if 'H' not in [atm[0], atm2[0]]:
        continue

      if distMat[i, j, 0, 1] > 5.5:
        continue

      if distMat[i, j, 0, 1] > 0.01 and distMat[i, j, 0, 1] < 5.5:
        dist = distMat[i, j, 0,1] # giving 'rubber band' 40% more resistance
        distRound = round(dist, 2)
        atmList.append(atm + '-'+ atm2)
        #atmList.append(atm2)
        #distList.append(str(nSeq) +'_'+ atm +'-'+ str(nSeq2) + '_' +atm2)
        distList.append(distRound)
        resList.append(str(nSeq)+'-'+str(nSeq2))
        #resList.append(str(nSeq2))
        #coordList.append(str(nSeq)+ atm + str(x) + str(y) + str(z) + ' and ' + \
        #                 str(nSeq2) + atm2 + str(x2) +str(y2) + str(z2))


  return {'HH atoms': atmList,
          'HH Residues': resList,
          'HH Distance': distList}
          #'HH coordinates': coordList}

pdb_file = '/content/' + str(PDB_ID) + '.pdb'

pdb_list = readPDB(pdb_file, 0)
#print(pdb_list)
distMat, keyList = createDistanceMatrix(pdb_list)
#print (distMat)

HHresults = hhDist(pdb_list)
print (HHresults)

#@title Assign Chemical Shifts

chemShifts = results['Chemical Shifts']

def get_shift(seqidx, atomname):
  filterAtoms = list(filter(lambda x :x[0] == str(seqidx) and x[3] ==atomname,
                            chemShifts))
  if len(filterAtoms) == 0:
    return -9999
  return float(filterAtoms[0][4])

atomname = HHresults['HH atoms']
segidx = HHresults['HH Residues']

atomname_list = []
for i in atomname:
  i_split = i.split('-')
  atomname_list.append(i_split)

for i in segidx:
  print (i)
  #print (i_split)

def distance2height(HHdist, offset = 0.0):
    """ distance scaling using r^-6 approximation for H-H """

    min_hh = 1.7  # closest distance between H atoms (1.70 A)
    max_hh = 3.4  # farthest distance observed between H atoms (1.70 * 2)

    approx = -6.0
    dist = min(HHdist, max_hh-offset)
    dist = max(HHdist, min_hh-offset)

    # A * r**-3 + B = I
    # A * min_cc**-3 + B = 1000000 arbituary max
    # A * max_cc**-3 + B = 10000   arbituary min
    # (min_cc**-3 - max_cc**-3) * A = 990000
    A = 990000.0 / ((min_hh-offset)**approx - (max_hh-offset)**approx)       # 75227372.04997641
    B = 10000.0 - A * (max_hh-offset)**-(min_hh-offset)                      # -19444.257193289242

    return A * dist**approx + B
HHdist = HHresults['HH Distance']

#print(HHdist)
for i in HHdist:
  a = distance2height(i, 2.18)
  print(a)

