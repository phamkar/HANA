 
'''
______________________________________________________________________________________________________________________________________________________________
This scripts evaluates the stat files generated by XPLOR-NIH after the initial run (cycle 0)--- not correct---. Here it'll set the initial endurance score as 20, an arbitrary
value. Then using the values within the stats file to set penalties score which will deduct from endurance score and remove any restraints that fall under the
set threshold.
______________________________________________________________________________________________________________________________________________________________
'''

import os, sys, re, math,statistics, proton_nomenclature #import neccesay libraries used throughout the code
import numpy as np
from math import sqrt
from collections import defaultdict


##############################################################################################################################################################
#                                                                       Parse Stats File                                                                     #       
##############################################################################################################################################################

def read_NOEPot(lines, pot_name):
    '''
    ____________________________________________________________________________________________________
    input: lines of stat file and name/type of potential energy (i.e alt, noe, hbond, etc.)
    output: viol_percent, viol_amount, viol_index, penalty, restraint_name.strip()]

    This function reads the stats file for the run. The stat files contains the restraint from all *.tbl
    ____________________________________________________________________________________________________
    '''

    key = f'violations in NOEPot term {pot_name}' # ex: 'violations in NOEPot term hbond'
    results = []
    for i in range(len(lines)): 
        line = lines[i]
        if line.find(key) == -1: # checks if the key is not present in the current line then find() returns -1, 
                                 # if found then a non-negative integer will be returned
            continue
        startidx = i
        for j in range(startidx + 4, len(lines)):
            line2 = lines[j]
            if line2 == '' or line2.startswith('violations'):
                break
            sp_list = line2.split()
            try:
                viol_percent, viol_amount, viol_index = float(sp_list[0]), float(sp_list[1]), int(sp_list[2])
                restraint_name = ' '.join(sp_list[3:])
            except:
                continue
            penalty = viol_percent * viol_amount / 25.0 # was 50 4/17/25
            results.append([viol_percent, viol_amount, viol_index, 
                            penalty, restraint_name.strip()])
    
    return results

def read_XplorPot(lines, pot_name):
    '''
    ________________________________________________________________________________________________________________________
    input: lines of stat file and name/type of potential energy i.e CDIH (dihedral restraints), ANGL, BOND, IMPR(?), and VDW
    output: [viol_percent, viol_amount, viol_index, penalty, restraint_name]
    This function is similar to read_NOEPot function. It takes the lines from the stat file and search for the term
    'violations in XPLORPot term {pot_name}', instead of 'violations in NOEPot term {pot_name}'. For this function,
    the CDIH (dihedral restraints), ANGL, BOND, IMPR(?), and VDW were determined.
    ________________________________________________________________________________________________________________________
    '''

    key = f'violations in XPLORPot term {pot_name}'
    results = []
    for i in range(len(lines)):
        line = lines[i]
        if line.find(key) == -1:
            continue
        startidx = i
        for j in range(startidx + 4, len(lines)):
            line2 = lines[j]
            if line2 == '' or line2.startswith('violations'):
                break
            sp_list = line2.split()
            try:
                viol_percent, viol_amount, viol_index = float(sp_list[0]), float(sp_list[1]), int(sp_list[2])
                restraint_name = ' '.join(sp_list[3:])
            except:
                continue
            penalty = viol_percent * viol_amount / 1000.
            results.append([viol_percent, viol_amount, viol_index, 
                            penalty, restraint_name])
    
    return results

def parse_xplor_stats(stats_file):
    '''
    ______________________________________________________________________________________________________________
    input: stats file pathway
    output: NOEPot and XPLOrPot restraints are added to a dictionary called 'result_dict'
    This function is now parsing the stat file. It uses read_NOEPot and read_XplorPot. Here lines of the stat file
    is defined. 
    ______________________________________________________________________________________________________________
    '''

    if not os.path.exists(stats_file):
        return []
    f = open(stats_file, 'r')
    lines = f.readlines()
    f.close()

    results_dict = {}
    # start parsing to get information after the run
    alt_results = read_NOEPot(lines, 'alt')
    results_dict['alt_viol'] = alt_results

    noe_results = read_NOEPot(lines, 'noe')
    results_dict['noe_viol'] = noe_results

    hbond_results = read_NOEPot(lines, 'hbond')
    results_dict['hbond_viol'] = hbond_results

    distca_results = read_NOEPot(lines, 'distca')
    results_dict['distca_viol'] = distca_results

    CDIH_results = read_XplorPot(lines, 'CDIH')
    results_dict['CDIH_viol'] = CDIH_results

    return results_dict

'''
______________________________________________________________________________________________________
Summary on what is happening so far: The stat file that was generated through XPLOR-NIH run is parsed. 
Its restraints are defined and added to a dictionary to be called later on in the script.
______________________________________________________________________________________________________
'''

##############################################################################################################################################################
#                                                                       Get and Set Restraints                                                               #
##############################################################################################################################################################

def get_restraint_use(restraint):
    '''
    ____________________________________________________________________________________________________
    input: restraints 
    output: If the restraint does NOT have the "!" character then it strips that line and returns it
    This function is search for any restraints within the alt.tbl. It searches for the character '!' and
    strips the line if it does not have the "!" character.  
    ____________________________________________________________________________________________________
    '''
    return restraint.strip() != '!'

 # The following function is redunant and I'm not sure how it is implemented?
    # Per Dr. Lee: it enables/disables a restraint. it must be you who should code when score goes below zero. 
   
def set_restraint_use(restraint, enable):
    '''
    _______________________________________________________________________________________________
    input: restraint and if it's true or false
    output: restraints or "! " + restraints

    This functions utilizes the get_restraint_use function to enable or disable the restraints. ??? 
    _______________________________________________________________________________________________
    '''
    if enable == True:
        # if restraint has '!' it'll return the line within the alt.tbl
        if not get_restraint_use(restraint):
            return restraint.strip()[1:].strip()
        return restraint
    # if enable is False and '!' does exist then it'll return the restraint
    if not get_restraint_use(restraint):
        return restraint
    return '! ' + restraint

##############################################################################################################################################################
#                                                                       Set Endurance Score                                                                  #
##############################################################################################################################################################

def endurance_score_exist(restraint):
    '''
    _______________________________________________________
    input: restraints
    output: True or False
    This function checks if the endurance score exists.
    Endurance score is found after '!ENDURANCE' characters.
    _______________________________________________________
    '''

    return restraint.strip().split()[-2] == '!ENDURANCE'

def get_endurance_score(restraint):
    '''
    _______________________________________________________________________
    input: restraints
    output: endurance score
    This function obtains the endurance score (if it exists). 
    If endurance score does not exist then it returns a null value of -1000
    _______________________________________________________________________
    '''
    if not endurance_score_exist(restraint):
        return -10000
    return float(restraint.strip().split()[-1])
    # return float(restraint.strip().split())

def set_endurance_score(restraint, score):
    '''
    ________________________________________________________________
    input: restraints and endurance score
    output: restraint and endurance score
    This function appends the restraints to the endurance score ???
    ________________________________________________________________
    '''
    if endurance_score_exist(restraint):
       return ' '.join(restraint.split()[:-1] + [str(score)])
    return restraint + f' !ENDURANCE {score}' 

##############################################################################################################################################################
#                                                                       Filter Through alt.tbl                                                               #
##############################################################################################################################################################

def filter_alt_file (restraint):
    '''
    __________________________________________________________________________________
    input: restraints
    output: segids+resids+atms
    This function filters for 'segid', 'resid', and atom names within the alt.tbl file.
    It searches for these term within chain A and B.
    __________________________________________________________________________________
    '''
    restraintStrip = restraint.strip().split()
    segids = []
    resids = []
    atms = []
    try:
        for i in range(len(restraintStrip)):
            
            if 'segid' in restraintStrip[i] or '(segid' in restraintStrip[i]:
                segids.append(restraintStrip[i+1])
            if 'resid' in restraintStrip[i]:
                resids.append(restraintStrip[i+1])
            if 'name' in restraintStrip[i]:
                atmName = restraintStrip[i+1]
                atmNameStrip = atmName.strip(')')
                atms.append(atmNameStrip)

    except IndexError:
        pass
    filterItems = segids+resids+atms
    # print (filterItems)
    return filterItems

##############################################################################################################################################################
#                                                                       Setting Penalties                                                                    #
##############################################################################################################################################################

def apply_penalty_to_restraint(intermediate_restraints_lines, high_alt_viol_list):
    '''
    __________________________________________________________________________________________________________________________________________________________
    input: restraints and a list of high violation terms
    output: restraints with new endurance score
    This funtion applies the penalties to obtain a new endurance score
    This function used the filter_alt_file function to obtain the needed values for comparison
    It parse through the high violation listed that was obtained from the stat file then it compares the values of viol list to the restaints of the alt file. 
    If the alt restraints are not in the stat violations then the code moves on with the one that are present. 
    Penalties from the stat file will be applied to these restraints to create a new endurance score.
    __________________________________________________________________________________________________________________________________________________________
    '''
    all_restraint = ''
    for i in range(len(intermediate_restraints_lines)):
        restraints = intermediate_restraints_lines[i]
        restraints_list  = filter_alt_file(restraints) # ['A', 'B', '121', '121', 'HA', 'HG']
        endurance_score = get_endurance_score(restraints)
        for j in range(len(high_alt_viol_list)):
            viol = high_alt_viol_list[j]
            viol_restraints = filter_alt_file(viol[4])
            penalty = viol[3]
            if restraints_list == viol_restraints:
                new_endurance_score = endurance_score - penalty
                new_restraint = set_endurance_score(restraints, new_endurance_score)
                restraints = new_restraint
                
        all_restraint += restraints + '\n'
    return all_restraint
    
##############################################################################################################################################################
#                                                                       Re-Write alt.tbl File                                                                #
##############################################################################################################################################################

def write_alt_file(new_altFileLines, cycle_num, folder_name):
    '''
    ________________________________________________________________________________________________________________________________________________________
    input: new lines containing restraints and endurance score, cycle number
    output: new alt.tbl file for Xplor-NIH
    This function will write the alt file for the new cycle directory. It'll make a new directory base on the cycle number then copy the required files from 
    previous cycle. 
    The final step is creating the alt tbl in the new cycle directory. The file content would be the result from the apply_penalty_to_restraint
    function.
    ________________________________________________________________________________________________________________________________________________________
    '''
    os.system(f'mkdir {folder_name}{cycle_num+1}')
    os.system(f'cp -r {folder_name}{cycle_num}/*.tbl {folder_name}{cycle_num+1}/')
    os.system(f'cp -r {folder_name}{cycle_num}/finalx.pdb {folder_name}{cycle_num+1}/')
    os.system(f'cp -r {folder_name}{cycle_num}/ahna_dimer.py {folder_name}{cycle_num+1}/')
    f = open(f'{folder_name}{cycle_num+1}/all_alt.tbl', 'w')
    f.write(''.join(new_altFileLines))
    f.close()

    return f
##############################################################################################################################################################
#                                                               Analyze intermediate structure                                                               #
##############################################################################################################################################################
def renumber_seq_PDB(pdb_file):
  output_list = []
  with open (pdb_file,'r') as infile:
    current_chain_id = None
    current_reside_number = None
    new_residue_counter = 0

    seen_residues_in_chain = {}

    for line in infile:
       if line.startswith('ATOM'):
          c = line[21].strip()
          nSeq = int(line[23:26].strip())

          original_res_tuple = (c, nSeq)

          if c != current_chain_id:
            current_chain_id = c
            new_residue_counter = 0 
            seen_residues_in_chain = {}

            if original_res_tuple not in seen_residues_in_chain:
              new_residue_counter += 1
              seen_residues_in_chain[original_res_tuple] = new_residue_counter
          else:
            if original_res_tuple not in seen_residues_in_chain:
              new_residue_counter += 1
              seen_residues_in_chain[original_res_tuple] = new_residue_counter
          
          new_res_num_for_line = seen_residues_in_chain[original_res_tuple]
          new_line = line[:22] + "{:>4}".format(new_res_num_for_line) + line[26:]
          output_list.append(new_line)
  return output_list
def readPDB(pdb_list, modelnumber, nuclei=['H',]):
  """
  Parameters
  ----------
  uploaded_pdb : address to a .pdb file
  modelnumber : the model number in the pdb (starting from 1)
  Returns
  -------
  pdb_list: a list of each [Nseq, atom's coordinates, aa, atom]
  """
  modelList = []
  # fill modelList
  for line in pdb_list:
    # print (line)
    if line[0:5] == 'MODEL':
      modelList.append([])
    if line[0:4] != 'ATOM':
      continue
    if line[12:16].strip()[0] not in nuclei:
      continue
    aaa = line[17:20].strip()
    atm = line[12:16].strip()
    nSeq = int(line[23:26].strip()) # <residue sequence>
    x = float(line[30:38].strip())
    y = float(line[38:46].strip())
    z = float(line[46:54].strip())
    c = line[-5].strip() # <chain_ID>
    # define and add psuedo atoms
    if atm == 'H':
        atm = atm.replace('H','HN')
    if len(atm)> 3:
        match = re.search(r"(\D+)\d+$", atm)
        if match: 
          atm = re.sub(r'\d+$', '*', atm)
    # in case MODEL not in PDB.
    if len(modelList) == 0:
      modelList.append([])
    modelList[-1].append( [nSeq, x, y, z, aaa, proton_nomenclature.AAA_dict[aaa], atm, c] )
  return modelList[modelnumber-1]

def distance3D(atom1, atom2):
    """ 
    _________________________________________________________
    takes two coordinates. ex: ((26.266, 25.413, 2.842),
                             (26.913, 26.639, -3.51))
    returns the distance

    Euclidean calculation
    _________________________________________________________
    """
    return sqrt((atom1[0] - atom2[0]) ** 2 +
              (atom1[1] - atom2[1]) ** 2 +
              (atom1[2] - atom2[2]) ** 2)

def analyze_intermediate_structures(folder_name,cycle_num):
    
    # Step 1: parse and analyze individual cycle
    inter_pdb_path = f'{folder_name}{cycle_num}/'
    inter_pdb_file_list = []

    for files in os.listdir(inter_pdb_path):
        if files.startswith('ahna') and files.endswith('.pdb'):
            inter_pdb_file_list.append(os.path.join(inter_pdb_path,files))

    cycle_distances_by_pair = defaultdict(list)  # build dictionary

    for pdb_paths in inter_pdb_file_list:
        renumber_inter_pdb = renumber_seq_PDB(pdb_paths)
        read_inter_pdb = readPDB(renumber_inter_pdb,1,nuclei=['H',])
        for i in range(len(read_inter_pdb)):
            nSeq, x, y, z, aaa, a, atm, c = read_inter_pdb[i]
            coord1 = (x,y,z)
            for j in range(i+1,len(read_inter_pdb)):
                nSeq2, x2, y2, z2, aaa2, a2, atm2, c2 = read_inter_pdb[j]
                coord2 = (x2,y2,z2)

                if c == c2: # interdomain only
                    continue
                
                dist = distance3D(coord1,coord2)

                # set keys for dictionary - cycle_distances_by_pair
                key1, key2 = (c,nSeq,atm), (c2,nSeq2,atm2)
                sorted_keys = sorted([key1,key2]) # sorted tuple to ensure A-B = B-A
                canonical_key = (
                    sorted_keys[0][0], str(sorted_keys[0][1]), sorted_keys[0][2],
                        sorted_keys[1][0], str(sorted_keys[1][1]), sorted_keys[1][2]
                )
                cycle_distances_by_pair[canonical_key].append(dist) # ('A', '5', 'HG', 'B', '6', 'HB2'): [3.37, 3.56]
    pair_in_cycle = {}
    for pair_key, dist_list in cycle_distances_by_pair.items():
        avg_dist = statistics.mean(dist_list)
        if avg_dist > 6:
            continue
        pair_in_cycle[pair_key]= avg_dist

    # Step 2 analyze and update alt.tbl

    all_alt_path = f'{folder_name}{cycle_num}/all_alt.tbl'

    f = open(all_alt_path,'r')
    all_alt_lines = f.readlines()
    f.close()

    filter_restraints_list = []
    endurance_score_dict= {}
    new_all_alt_line = []

    for line in range(len(all_alt_lines)):
        restraints = all_alt_lines[line]
        filter_restraints = filter_alt_file(restraints) # ['A', 'B', '121', '121', 'HA', 'HG']
        if len(filter_restraints) == 0:
            continue
        c,c2,nSeq,nSeq2,atm,atm2 = filter_restraints
        key1, key2 = (c, nSeq, atm), (c2, nSeq2, atm2)
        sorted_keys = sorted([key1,key2])
        alt_pair_key = (
                        sorted_keys[0][0], str(sorted_keys[0][1]), sorted_keys[0][2],
                        sorted_keys[1][0], str(sorted_keys[1][1]), sorted_keys[1][2]           
                        )
        
        endurance_score = get_endurance_score(restraints)
        endurance_score_dict[alt_pair_key] = endurance_score
        filter_restraints_list.append(filter_restraints)
        if alt_pair_key in pair_in_cycle:
            new_endurance_score = min(endurance_score + 3, 20)
            endurance_score_dict[alt_pair_key] = new_endurance_score
        else:
            endurance_score_dict[alt_pair_key] = 0

    for restraints in filter_restraints_list:
        c,c2,nSeq,nSeq2,atm,atm2 = restraints
        pair_key = (c, nSeq, atm, c2, nSeq2, atm2)
        endurance_score = endurance_score_dict[pair_key]
        try:
            dist = pair_in_cycle[pair_key]
        except:
            dist = 5.5
        dist2 = dist - 1.7
        line = f'assign (segid {c} and resid {nSeq} and name {atm}) \
                (segid {c2} and resid {nSeq2} and name {atm2}) \
                {dist: 0.2f} {dist2: 0.2f} 0.0 \
                !ENDURANCE {endurance_score} \n'
        new_all_alt_line.append(line)

    return new_all_alt_line     

##############################################################################################################################################################
#                                                                Implementation: Cycling Through Files                                                       #
##############################################################################################################################################################

def cycle(folder_name, cycle_num):

    '''
    ___________________________________________________________________________________________________________________________________________
    input: directory name, cycle number
    output: new alt.tbl file
    This function will cycle through the code depending how many time was specified. 
    It'll take make the folder for cycle 0 and copy neccesary restraint files from the Best Evaluated directory. 
    When the Xplor-NIH is ran from cycle 0, it should place the results within that cycle directory,then the restraint files will be copied to 
    the next cycle directory. 
    'folder_name' would be the cycle directories' parent directory: ' /Users/Karen/AHNA/HERC5/HERC5_VS/'
    This function will also set the new endurance score using the apply_penalty_to_restraint function then it'll append the restraint to a list 
    ___________________________________________________________________________________________________________________________________________
    '''
    # folder_name = ./{PDB_id}/{job_id}/

    # get alt.tbl file
    all_alt_path = f'{folder_name}{cycle_num}/all_alt.tbl'

    new_lines = ''
 
    all_alt_path_file = open (all_alt_path, 'r')
    all_alt_path_file_lines = all_alt_path_file.readlines()
    all_alt_path_file.close()

    for i in range(len(all_alt_path_file_lines)):
        restraints = all_alt_path_file_lines[i].strip()
        if restraints:
            if not endurance_score_exist(restraints):
                restraints = set_endurance_score(restraints, 20)
                all_alt_path_file_lines[i] = restraints
                new_lines += restraints + '\n'
            elif endurance_score_exist(restraints):
                score = float(restraints.split()[-1])
                if cycle_num <= 3:
                    if score >= 15:
                        new_lines += restraints + '\n'
                elif cycle_num > 3 and cycle_num <= 8:
                    if score >= 10:
                        new_lines += restraints + '\n'
                elif cycle_num > 8:
                    if score > 5:
                        new_lines += restraints + '\n'
    # write new alt.tbl file with endurance score; still running in current directory
    f = open(f'{folder_name}{cycle_num}/alt.tbl', 'w')
    f.write(new_lines) 
    f.close()
    cmd = f'cd {folder_name}{cycle_num}; xplor -py ahna_dimer.py'
    os.system(cmd) 

    # get stats file after run
    statFile = os.path.join(folder_name, str(cycle_num), 'ahna_dimer_##.pdb.stats')
    # Parse stat files and obtain violation list. Filter for violations with a score highter than 60.
    parse_xplor_stats_dict = parse_xplor_stats(statFile) 
    alt_viol_dict = parse_xplor_stats_dict['alt_viol'] #[[100.0, 0.99, 2 22, 0.99, '( segid A and resid 72 and name OG ) ( segid B and resid 80 and name HH21 )']

    high_alt_viol_list = list(filter(lambda x: x[0] >=50.0, alt_viol_dict)) # filter out restraints with violation % > 50 (used to be 60)
                                                                                # robust restraints to use; users can choose different levels of violations %

    intermediate_restraints_lines = analyze_intermediate_structures(folder_name,cycle_num)
    all_new_restraint = apply_penalty_to_restraint(intermediate_restraints_lines, high_alt_viol_list)
    new_alt_tbl = write_alt_file(all_new_restraint, cycle_num, folder_name)
    return new_alt_tbl

        
##############################################################################################################################################################
#                                                                               Implementation                                                               #
##############################################################################################################################################################
job_id = '250304_204659_132'
PDB_id= '6TV5'
folder_name = f'./{PDB_id}/{job_id}/'

cycle_num = 10
for cycles in range(cycle_num+1):
    if cycles == 0:
        if not os.path.exists(f'{folder_name}{cycles}'):
            os.system(f'mkdir {folder_name}{cycles}; cp -r ./{PDB_id}/{job_id}/BestEvaluated/ {folder_name}{cycles}')
        else:
            os.system(f'cp -r ./{PDB_id}/{job_id}/BestEvaluated/ {folder_name}{cycles}')
    cycle(folder_name, cycles)


##############################################################################################################################################################
#                                                                           Workspace                                                                        #
#                                                                            ()___()                                                                         #
#                                                                            (O u O)                                                                         #
#                                                                            ( www )                                                                         #
##############################################################################################################################################################




    